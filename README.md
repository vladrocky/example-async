# Стратегия запуска async

 механизм будущих резултатов
Сейчас я накину несколько тезизов, постарайтесь записать на подкорке, может быть не до конца понятно далее будут примеры и мы со все разберемся
этот механизм наиболее актуален для задач когда нам необходимо взять какую-то тяжеловесную задачу отдать ее на выполнение и вернуться к ней одни раз когда нам это потребуется
тут в тексте приводится сравнеие с условными переменными - речь о том что этот механизм пригоден когда нам необходимо постоянно получать какие-то значения из вторичных потоков
например у нас реализован конвеер задачи мы складываем в очередь - один поток периодически тула кладет какую-то задачу другой забирает 
самой низкоуровневой реаизация это свяка future - promise
future - это пассивная сущность которая позволяет получать разделяемые значения 
механизм позволяет не думать о join или detach как в случае использования thread
promise - напротив активен и позваляет передавать данные между потоками
async - позволяет нам запускать поток на исполнение сразу при инициализации экземпляра класса future
дополнительно возможно успеем атронуть pacaged_task

Начнем с async
функция async имеет несколько перегрузок
как минимум необходимо передать ссылку на функциональную сущьность, например функции или как показано на слайде лямбда-выражение
так же есть флаг позваляющий указать выпонение в отдельном потоке, либо просто отложенное выполнение (при вызове метода get или wait) и аргументы функции 


Сознательно привел пример где мы вроде как применяем async но выполнение этого кода будет последовательным как если бы мы просто вызвали функцию worker
На самом деле для запуска worker в отдельном потоке нам необходимо инициализировать экземпляр класса future вызвав функцию async

По этому достаточно в приведенном выше примере поправить одну строчку и мы уже получаем асинхронный код
конечно максимально тривиальный
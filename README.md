# Стратегия запуска async

## Механизм будущих резултатов
`std::async, std::future, std::promise`

Самая низкоуровневая реаизация это свяка `future - promise`


* **`future`** - это пассивная сущность, которая позволяет получать разделяемые значения. Механизм позволяет не думать о `join` или `detach` как в случае использования `thread`. Представляет из себя некую абстракцию над значением или объектом, вычисление которого происходит отложено, предоставляет доступ к значению если оно уже было вычислено, объекты этого класса служат некоторым проводником для разделяемых значений и флагом их состояния.
* **`promise`** - напротив, активен и позваляет передавать данные между потоками. `promise` - обещанное значение, позволяет вернуть вычисляемое значение из потока у экземпляров этого класса существует метод получения `future`.
* **`async`** - используется для асинхронного запуска функциональной сущности отдельный поток создается при инициализации экземпляр класса `future` возвращаемым значением `async`.

## async
Функция `async` имеет несколько перегрузок. Как минимум, необходимо передать ссылку на функциональную сущьность, например, функции или как показано в примере - лямбда-выражение. Есть флаг позваляющий указать выпонение в отдельном потоке, либо просто отложенное выполнение (при вызове метода `get` или `wait`) и аргументы функции.
 ```cpp
 #include <future>
…
// флаг по умолчанию
// отдельный поток
// будет создан объект класса thread
std::async(std::launch::async, [] ( ) { … });
…
// отложенное выполнение
std::async(std::launch::deferred, [ ] ( ) { … });
…
 ```
Итак, в качестве параметров `async` принимает:
* флаг (опционально)
* функциональную сущность
* ее аргументы
```cpp
void worker(int value)
{
	…
}
…
std::async(std::launch::async, worker, 5)
…
```
Если режим запуска `launch::deferred` или `async` явно не указан, функция `async` выбирает его автоматически.

<h2 style="color:#ea3e47">Неправильный пример</h2>

```cpp
 void worker() 
{
        …
 for (int index = 0; index < 10; index++)
{
            ++value;
            cout << "(id thread = " << this_thread::get_id() << ") Value = " << value << endl;

            this_thread::sleep_for(std::chrono::milliseconds(10));            
}
…
}
…        
// передаем в async ссылку на функциональную сущность
std::async(worker);

cout << "(id thread = " << this_thread::get_id() << ") Value = " << value << endl;
```
Сознательно привел пример, где мы вроде как применяем `async`, но выполнение этого кода будет последовательным как если бы мы просто вызвали функцию `worker`. На самом деле для запуска `worker` в отдельном потоке нам необходимо инициализировать экземпляр класса `future` вызвав функцию `async`.

<h2 style="color:#16bb8e">Асинхронное выполнение</h2>

Поэтому достаточно в приведенном выше примере поправить одну строчку и мы уже получаем асинхронный код
(конечно максимально тривиальный).
```cpp
// передаем в async ссылку на функциональную сущность
// инициализируем объект класса future
future<void> simple_futer = std::async(worker);
```